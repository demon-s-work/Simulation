//------------------------------------------------------------------------------
// <auto-generated>
//     Automatically generated by the Fast Binary Encoding compiler, do not modify!
//     https://github.com/chronoxor/FastBinaryEncoding
//     Source: contract.txt
//     FBE version: 1.14.2.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Runtime.Serialization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace com.simulation.contract {

    public struct SimpleMessage : IComparable, IComparable<SimpleMessage>, IEquatable<SimpleMessage>
    {
        public string Message;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        public static SimpleMessage Default => new SimpleMessage
        {
            Message = ""
        };

        public SimpleMessage(string Message)
        {
            this.Message = Message;
        }

        public SimpleMessage Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.simulation.contract.FBE.SimpleMessageModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.simulation.contract.FBE.SimpleMessageModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(SimpleMessage other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is SimpleMessage))
                return false;
            return true;
        }

        public bool Equals(SimpleMessage other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(SimpleMessage lhs, SimpleMessage rhs) => lhs.Equals(rhs);
        public static bool operator!=(SimpleMessage lhs, SimpleMessage rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("SimpleMessage(");
            sb.Append("Message="); if (Message != null) sb.Append("\"").Append(Message).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public static com.simulation.FBE.FieldModelValueType<SimpleMessage> CreateFieldModel(com.simulation.FBE.Buffer buffer, long offset) { return new contract.FBE.FieldModelSimpleMessage(buffer, offset); }
    }

} // namespace com.simulation.contract

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding SimpleMessage field model
    public class FieldModelSimpleMessage : com.simulation.FBE.FieldModelValueType<SimpleMessage>
    {
        public readonly com.simulation.FBE.FieldModelReferenceType<string> Message;

        public FieldModelSimpleMessage(com.simulation.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            Message = com.simulation.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.simulation.FBE.BaseTypes.STRING, buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + Message.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + Message.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.simulation.FBE.FieldModelValueType<SimpleMessage> Clone() { return new FieldModelSimpleMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + Message.FBESize) > fbeStructSize)
                return true;
            if (!Message.Verify())
                return false;
            fbeCurrentSize += Message.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out SimpleMessage fbeValue) { Get(out fbeValue, SimpleMessage.Default); }
        public override void Get(out SimpleMessage fbeValue, SimpleMessage defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out SimpleMessage fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = SimpleMessage.Default;

            if ((fbeCurrentSize + Message.FBESize) <= fbeStructSize)
                Message.Get(out fbeValue.Message);
            else
                fbeValue.Message = "";
            fbeCurrentSize += Message.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(SimpleMessage fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(SimpleMessage fbeValue)
        {
            Message.Set(fbeValue.Message);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding SimpleMessage model
    public class SimpleMessageModel : com.simulation.FBE.Model
    {
        public readonly FieldModelSimpleMessage model;

        public SimpleMessageModel() { model = new FieldModelSimpleMessage(Buffer, 4); }
        public SimpleMessageModel(com.simulation.FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimpleMessage(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimpleMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(SimpleMessage value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out SimpleMessage value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = SimpleMessage.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = SimpleMessage.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract {

    public struct SimpleRequest : IComparable, IComparable<SimpleRequest>, IEquatable<SimpleRequest>
    {
        public string Data;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        public static SimpleRequest Default => new SimpleRequest
        {
            Data = ""
        };

        public SimpleRequest(string Data)
        {
            this.Data = Data;
        }

        public SimpleRequest Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.simulation.contract.FBE.SimpleRequestModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.simulation.contract.FBE.SimpleRequestModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(SimpleRequest other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is SimpleRequest))
                return false;
            return true;
        }

        public bool Equals(SimpleRequest other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(SimpleRequest lhs, SimpleRequest rhs) => lhs.Equals(rhs);
        public static bool operator!=(SimpleRequest lhs, SimpleRequest rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("SimpleRequest(");
            sb.Append("Data="); if (Data != null) sb.Append("\"").Append(Data).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public static com.simulation.FBE.FieldModelValueType<SimpleRequest> CreateFieldModel(com.simulation.FBE.Buffer buffer, long offset) { return new contract.FBE.FieldModelSimpleRequest(buffer, offset); }
    }

} // namespace com.simulation.contract

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding SimpleRequest field model
    public class FieldModelSimpleRequest : com.simulation.FBE.FieldModelValueType<SimpleRequest>
    {
        public readonly com.simulation.FBE.FieldModelReferenceType<string> Data;

        public FieldModelSimpleRequest(com.simulation.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            Data = com.simulation.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.simulation.FBE.BaseTypes.STRING, buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + Data.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + Data.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.simulation.FBE.FieldModelValueType<SimpleRequest> Clone() { return new FieldModelSimpleRequest(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + Data.FBESize) > fbeStructSize)
                return true;
            if (!Data.Verify())
                return false;
            fbeCurrentSize += Data.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out SimpleRequest fbeValue) { Get(out fbeValue, SimpleRequest.Default); }
        public override void Get(out SimpleRequest fbeValue, SimpleRequest defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out SimpleRequest fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = SimpleRequest.Default;

            if ((fbeCurrentSize + Data.FBESize) <= fbeStructSize)
                Data.Get(out fbeValue.Data);
            else
                fbeValue.Data = "";
            fbeCurrentSize += Data.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(SimpleRequest fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(SimpleRequest fbeValue)
        {
            Data.Set(fbeValue.Data);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding SimpleRequest model
    public class SimpleRequestModel : com.simulation.FBE.Model
    {
        public readonly FieldModelSimpleRequest model;

        public SimpleRequestModel() { model = new FieldModelSimpleRequest(Buffer, 4); }
        public SimpleRequestModel(com.simulation.FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimpleRequest(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimpleRequest.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(SimpleRequest value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out SimpleRequest value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = SimpleRequest.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = SimpleRequest.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract {

    public struct SimpleResponse : IComparable, IComparable<SimpleResponse>, IEquatable<SimpleResponse>
    {
        public string Data;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        public static SimpleResponse Default => new SimpleResponse
        {
            Data = ""
        };

        public SimpleResponse(string Data)
        {
            this.Data = Data;
        }

        public SimpleResponse Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.simulation.contract.FBE.SimpleResponseModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.simulation.contract.FBE.SimpleResponseModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(SimpleResponse other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is SimpleResponse))
                return false;
            return true;
        }

        public bool Equals(SimpleResponse other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(SimpleResponse lhs, SimpleResponse rhs) => lhs.Equals(rhs);
        public static bool operator!=(SimpleResponse lhs, SimpleResponse rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("SimpleResponse(");
            sb.Append("Data="); if (Data != null) sb.Append("\"").Append(Data).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public static com.simulation.FBE.FieldModelValueType<SimpleResponse> CreateFieldModel(com.simulation.FBE.Buffer buffer, long offset) { return new contract.FBE.FieldModelSimpleResponse(buffer, offset); }
    }

} // namespace com.simulation.contract

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding SimpleResponse field model
    public class FieldModelSimpleResponse : com.simulation.FBE.FieldModelValueType<SimpleResponse>
    {
        public readonly com.simulation.FBE.FieldModelReferenceType<string> Data;

        public FieldModelSimpleResponse(com.simulation.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            Data = com.simulation.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.simulation.FBE.BaseTypes.STRING, buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + Data.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + Data.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.simulation.FBE.FieldModelValueType<SimpleResponse> Clone() { return new FieldModelSimpleResponse(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + Data.FBESize) > fbeStructSize)
                return true;
            if (!Data.Verify())
                return false;
            fbeCurrentSize += Data.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out SimpleResponse fbeValue) { Get(out fbeValue, SimpleResponse.Default); }
        public override void Get(out SimpleResponse fbeValue, SimpleResponse defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out SimpleResponse fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = SimpleResponse.Default;

            if ((fbeCurrentSize + Data.FBESize) <= fbeStructSize)
                Data.Get(out fbeValue.Data);
            else
                fbeValue.Data = "";
            fbeCurrentSize += Data.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(SimpleResponse fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(SimpleResponse fbeValue)
        {
            Data.Set(fbeValue.Data);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding SimpleResponse model
    public class SimpleResponseModel : com.simulation.FBE.Model
    {
        public readonly FieldModelSimpleResponse model;

        public SimpleResponseModel() { model = new FieldModelSimpleResponse(Buffer, 4); }
        public SimpleResponseModel(com.simulation.FBE.Buffer buffer) : base(buffer) { model = new FieldModelSimpleResponse(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelSimpleResponse.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(SimpleResponse value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out SimpleResponse value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = SimpleResponse.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = SimpleResponse.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract {

    public struct LoginMessage : IComparable, IComparable<LoginMessage>, IEquatable<LoginMessage>
    {
        public string Login;
        public Guid id => Guid.Empty;

        public const long FBETypeConst = 4;
        public long FBEType => FBETypeConst;

        public static LoginMessage Default => new LoginMessage
        {
            Login = ""
        };

        public LoginMessage(string Login)
        {
            this.Login = Login;
        }

        public LoginMessage Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new com.simulation.contract.FBE.LoginMessageModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new com.simulation.contract.FBE.LoginMessageModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            return result;
        }

        public int CompareTo(LoginMessage other)
        {
            int result = 0;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is LoginMessage))
                return false;
            return true;
        }

        public bool Equals(LoginMessage other)
        {
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            return hash;
        }

        public static bool operator==(LoginMessage lhs, LoginMessage rhs) => lhs.Equals(rhs);
        public static bool operator!=(LoginMessage lhs, LoginMessage rhs) => !(lhs == rhs);

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("LoginMessage(");
            sb.Append("Login="); if (Login != null) sb.Append("\"").Append(Login).Append("\""); else sb.Append("null");
            sb.Append(")");
            return sb.ToString();
        }

        public static com.simulation.FBE.FieldModelValueType<LoginMessage> CreateFieldModel(com.simulation.FBE.Buffer buffer, long offset) { return new contract.FBE.FieldModelLoginMessage(buffer, offset); }
    }

} // namespace com.simulation.contract

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding LoginMessage field model
    public class FieldModelLoginMessage : com.simulation.FBE.FieldModelValueType<LoginMessage>
    {
        public readonly com.simulation.FBE.FieldModelReferenceType<string> Login;

        public FieldModelLoginMessage(com.simulation.FBE.Buffer buffer, long offset) : base(buffer, offset)
        {
            Login = com.simulation.FBE.FieldModelReferenceType<string>.CreateFieldModel(com.simulation.FBE.BaseTypes.STRING, buffer, 4 + 4);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + Login.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + Login.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 4;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override com.simulation.FBE.FieldModelValueType<LoginMessage> Clone() { return new FieldModelLoginMessage(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + Login.FBESize) > fbeStructSize)
                return true;
            if (!Login.Verify())
                return false;
            fbeCurrentSize += Login.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out LoginMessage fbeValue) { Get(out fbeValue, LoginMessage.Default); }
        public override void Get(out LoginMessage fbeValue, LoginMessage defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out LoginMessage fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = LoginMessage.Default;

            if ((fbeCurrentSize + Login.FBESize) <= fbeStructSize)
                Login.Get(out fbeValue.Login);
            else
                fbeValue.Login = "";
            fbeCurrentSize += Login.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(LoginMessage fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(LoginMessage fbeValue)
        {
            Login.Set(fbeValue.Login);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    using global::com.simulation.contract;

    // Fast Binary Encoding LoginMessage model
    public class LoginMessageModel : com.simulation.FBE.Model
    {
        public readonly FieldModelLoginMessage model;

        public LoginMessageModel() { model = new FieldModelLoginMessage(Buffer, 4); }
        public LoginMessageModel(com.simulation.FBE.Buffer buffer) : base(buffer) { model = new FieldModelLoginMessage(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelLoginMessage.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(LoginMessage value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out LoginMessage value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = LoginMessage.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = LoginMessage.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    // Fast Binary Encoding com.simulation.contract protocol version
    public static class ProtocolVersion
    {
        // Protocol major version
        public const int Major = 1;
        // Protocol minor version
        public const int Minor = 0;
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    // Fast Binary Encoding com.simulation.contract sender listener interface
    public interface ISenderListener : com.simulation.FBE.ISenderListener
    {
    }

    // Fast Binary Encoding com.simulation.contract sender
    public class Sender : com.simulation.FBE.Sender, ISenderListener
    {
        // Sender models accessors
        public readonly SimpleMessageModel SimpleMessageModel;
        public readonly SimpleRequestModel SimpleRequestModel;
        public readonly SimpleResponseModel SimpleResponseModel;
        public readonly LoginMessageModel LoginMessageModel;

        public Sender() : base(false)
        {
            SimpleMessageModel = new SimpleMessageModel(Buffer);
            SimpleRequestModel = new SimpleRequestModel(Buffer);
            SimpleResponseModel = new SimpleResponseModel(Buffer);
            LoginMessageModel = new LoginMessageModel(Buffer);
        }
        public Sender(com.simulation.FBE.Buffer buffer) : base(buffer, false)
        {
            SimpleMessageModel = new SimpleMessageModel(Buffer);
            SimpleRequestModel = new SimpleRequestModel(Buffer);
            SimpleResponseModel = new SimpleResponseModel(Buffer);
            LoginMessageModel = new LoginMessageModel(Buffer);
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(ISenderListener listener, object obj)
        {
            switch (obj)
            {
                case global::com.simulation.contract.SimpleMessage value when value.FBEType == global::com.simulation.contract.SimpleMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.simulation.contract.SimpleRequest value when value.FBEType == global::com.simulation.contract.SimpleRequest.FBETypeConst: return SendListener(listener, value);
                case global::com.simulation.contract.SimpleResponse value when value.FBEType == global::com.simulation.contract.SimpleResponse.FBETypeConst: return SendListener(listener, value);
                case global::com.simulation.contract.LoginMessage value when value.FBEType == global::com.simulation.contract.LoginMessage.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::com.simulation.contract.SimpleMessage value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::com.simulation.contract.SimpleMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.SimpleMessage serialization failed!");
            Debug.Assert(SimpleMessageModel.Verify(), "com.simulation.contract.SimpleMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.simulation.contract.SimpleRequest value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::com.simulation.contract.SimpleRequest value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleRequestModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.SimpleRequest serialization failed!");
            Debug.Assert(SimpleRequestModel.Verify(), "com.simulation.contract.SimpleRequest validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.simulation.contract.SimpleResponse value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::com.simulation.contract.SimpleResponse value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleResponseModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.SimpleResponse serialization failed!");
            Debug.Assert(SimpleResponseModel.Verify(), "com.simulation.contract.SimpleResponse validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.simulation.contract.LoginMessage value) { return SendListener(this, value); }
        public long SendListener(ISenderListener listener, global::com.simulation.contract.LoginMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = LoginMessageModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.LoginMessage serialization failed!");
            Debug.Assert(LoginMessageModel.Verify(), "com.simulation.contract.LoginMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    // Fast Binary Encoding com.simulation.contract receiver listener interface
    public interface IReceiverListener : com.simulation.FBE.IReceiverListener
    {
        // Receive handlers
        void OnReceive(global::com.simulation.contract.SimpleMessage value) {}
        void OnReceive(global::com.simulation.contract.SimpleRequest value) {}
        void OnReceive(global::com.simulation.contract.SimpleResponse value) {}
        void OnReceive(global::com.simulation.contract.LoginMessage value) {}
    }

    // Fast Binary Encoding com.simulation.contract receiver
    public class Receiver : com.simulation.FBE.Receiver, IReceiverListener
    {
        // Receiver values accessors
        private global::com.simulation.contract.SimpleMessage SimpleMessageValue;
        private global::com.simulation.contract.SimpleRequest SimpleRequestValue;
        private global::com.simulation.contract.SimpleResponse SimpleResponseValue;
        private global::com.simulation.contract.LoginMessage LoginMessageValue;

        // Receiver models accessors
        private readonly SimpleMessageModel SimpleMessageModel;
        private readonly SimpleRequestModel SimpleRequestModel;
        private readonly SimpleResponseModel SimpleResponseModel;
        private readonly LoginMessageModel LoginMessageModel;

        public Receiver() : base(false)
        {
            SimpleMessageValue = global::com.simulation.contract.SimpleMessage.Default;
            SimpleMessageModel = new SimpleMessageModel();
            SimpleRequestValue = global::com.simulation.contract.SimpleRequest.Default;
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseValue = global::com.simulation.contract.SimpleResponse.Default;
            SimpleResponseModel = new SimpleResponseModel();
            LoginMessageValue = global::com.simulation.contract.LoginMessage.Default;
            LoginMessageModel = new LoginMessageModel();
        }
        public Receiver(com.simulation.FBE.Buffer buffer) : base(buffer, false)
        {
            SimpleMessageValue = global::com.simulation.contract.SimpleMessage.Default;
            SimpleMessageModel = new SimpleMessageModel();
            SimpleRequestValue = global::com.simulation.contract.SimpleRequest.Default;
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseValue = global::com.simulation.contract.SimpleResponse.Default;
            SimpleResponseModel = new SimpleResponseModel();
            LoginMessageValue = global::com.simulation.contract.LoginMessage.Default;
            LoginMessageModel = new LoginMessageModel();
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IReceiverListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case SimpleMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleMessageModel.Attach(buffer, offset);
                    Debug.Assert(SimpleMessageModel.Verify(), "com.simulation.contract.SimpleMessage validation failed!");
                    long deserialized = SimpleMessageModel.Deserialize(out SimpleMessageValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.SimpleMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleMessageValue);
                    return true;
                }
                case SimpleRequestModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleRequestModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRequestModel.Verify(), "com.simulation.contract.SimpleRequest validation failed!");
                    long deserialized = SimpleRequestModel.Deserialize(out SimpleRequestValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.SimpleRequest deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleRequestValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleRequestValue);
                    return true;
                }
                case SimpleResponseModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleResponseModel.Attach(buffer, offset);
                    Debug.Assert(SimpleResponseModel.Verify(), "com.simulation.contract.SimpleResponse validation failed!");
                    long deserialized = SimpleResponseModel.Deserialize(out SimpleResponseValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.SimpleResponse deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleResponseValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleResponseValue);
                    return true;
                }
                case LoginMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    LoginMessageModel.Attach(buffer, offset);
                    Debug.Assert(LoginMessageModel.Verify(), "com.simulation.contract.LoginMessage validation failed!");
                    long deserialized = LoginMessageModel.Deserialize(out LoginMessageValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.LoginMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = LoginMessageValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(LoginMessageValue);
                    return true;
                }
                default: break;
            }

            return false;
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    // Fast Binary Encoding com.simulation.contract proxy listener interface
    public interface IProxyListener : com.simulation.FBE.IReceiverListener
    {
        // Proxy handlers
        void OnProxy(SimpleMessageModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(SimpleRequestModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(SimpleResponseModel model, long type, byte[] buffer, long offset, long size) {}
        void OnProxy(LoginMessageModel model, long type, byte[] buffer, long offset, long size) {}
    }

    // Fast Binary Encoding com.simulation.contract proxy
    public class Proxy : com.simulation.FBE.Receiver, IProxyListener
    {
        // Proxy models accessors
        private readonly SimpleMessageModel SimpleMessageModel;
        private readonly SimpleRequestModel SimpleRequestModel;
        private readonly SimpleResponseModel SimpleResponseModel;
        private readonly LoginMessageModel LoginMessageModel;

        public Proxy() : base(false)
        {
            SimpleMessageModel = new SimpleMessageModel();
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseModel = new SimpleResponseModel();
            LoginMessageModel = new LoginMessageModel();
        }
        public Proxy(com.simulation.FBE.Buffer buffer) : base(buffer, false)
        {
            SimpleMessageModel = new SimpleMessageModel();
            SimpleRequestModel = new SimpleRequestModel();
            SimpleResponseModel = new SimpleResponseModel();
            LoginMessageModel = new LoginMessageModel();
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IProxyListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case SimpleMessageModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    SimpleMessageModel.Attach(buffer, offset);
                    Debug.Assert(SimpleMessageModel.Verify(), "com.simulation.contract.SimpleMessage validation failed!");

                    long fbeBegin = SimpleMessageModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(SimpleMessageModel, type, buffer, offset, size);
                    SimpleMessageModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case SimpleRequestModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    SimpleRequestModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRequestModel.Verify(), "com.simulation.contract.SimpleRequest validation failed!");

                    long fbeBegin = SimpleRequestModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(SimpleRequestModel, type, buffer, offset, size);
                    SimpleRequestModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case SimpleResponseModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    SimpleResponseModel.Attach(buffer, offset);
                    Debug.Assert(SimpleResponseModel.Verify(), "com.simulation.contract.SimpleResponse validation failed!");

                    long fbeBegin = SimpleResponseModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(SimpleResponseModel, type, buffer, offset, size);
                    SimpleResponseModel.model.GetEnd(fbeBegin);
                    return true;
                }
                case LoginMessageModel.FBETypeConst:
                {
                    // Attach the FBE stream to the proxy model
                    LoginMessageModel.Attach(buffer, offset);
                    Debug.Assert(LoginMessageModel.Verify(), "com.simulation.contract.LoginMessage validation failed!");

                    long fbeBegin = LoginMessageModel.model.GetBegin();
                    if (fbeBegin == 0)
                        return false;
                    // Call proxy handler
                    listener.OnProxy(LoginMessageModel, type, buffer, offset, size);
                    LoginMessageModel.model.GetEnd(fbeBegin);
                    return true;
                }
                default: break;
            }

            return false;
        }
    }

} // namespace com.simulation.contract.FBE

namespace com.simulation.contract.FBE {

    // Fast Binary Encoding com.simulation.contract client listener interface
    public interface IClientListener : com.simulation.FBE.IClientListener, ISenderListener, IReceiverListener
    {
    }

    // Fast Binary Encoding com.simulation.contract client
    public class Client : com.simulation.FBE.Client, IClientListener
    {
        // Client sender models accessors
        public readonly SimpleMessageModel SimpleMessageSenderModel;
        public readonly SimpleRequestModel SimpleRequestSenderModel;
        public readonly SimpleResponseModel SimpleResponseSenderModel;
        public readonly LoginMessageModel LoginMessageSenderModel;

        // Client receiver values accessors
        private global::com.simulation.contract.SimpleMessage SimpleMessageReceiverValue;
        private global::com.simulation.contract.SimpleRequest SimpleRequestReceiverValue;
        private global::com.simulation.contract.SimpleResponse SimpleResponseReceiverValue;
        private global::com.simulation.contract.LoginMessage LoginMessageReceiverValue;

        // Client receiver models accessors
        private readonly SimpleMessageModel SimpleMessageReceiverModel;
        private readonly SimpleRequestModel SimpleRequestReceiverModel;
        private readonly SimpleResponseModel SimpleResponseReceiverModel;
        private readonly LoginMessageModel LoginMessageReceiverModel;

        // Client requests cache fields
        private Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.simulation.contract.SimpleResponse>>> _requestsByIdSimpleResponse;
        private SortedDictionary<DateTime, Guid> _requestsByTimestampSimpleResponse;

        public Client() : base(false)
        {
            SimpleMessageSenderModel = new SimpleMessageModel(SendBuffer);
            SimpleMessageReceiverValue = global::com.simulation.contract.SimpleMessage.Default;
            SimpleMessageReceiverModel = new SimpleMessageModel();
            SimpleRequestSenderModel = new SimpleRequestModel(SendBuffer);
            SimpleRequestReceiverValue = global::com.simulation.contract.SimpleRequest.Default;
            SimpleRequestReceiverModel = new SimpleRequestModel();
            SimpleResponseSenderModel = new SimpleResponseModel(SendBuffer);
            SimpleResponseReceiverValue = global::com.simulation.contract.SimpleResponse.Default;
            SimpleResponseReceiverModel = new SimpleResponseModel();
            LoginMessageSenderModel = new LoginMessageModel(SendBuffer);
            LoginMessageReceiverValue = global::com.simulation.contract.LoginMessage.Default;
            LoginMessageReceiverModel = new LoginMessageModel();
            _requestsByIdSimpleResponse = new Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.simulation.contract.SimpleResponse>>>();
            _requestsByTimestampSimpleResponse = new SortedDictionary<DateTime, Guid>();
        }
        public Client(com.simulation.FBE.Buffer sendBuffer, com.simulation.FBE.Buffer receiveBuffer) : base(sendBuffer, receiveBuffer, false)
        {
            SimpleMessageSenderModel = new SimpleMessageModel(SendBuffer);
            SimpleMessageReceiverValue = global::com.simulation.contract.SimpleMessage.Default;
            SimpleMessageReceiverModel = new SimpleMessageModel();
            SimpleRequestSenderModel = new SimpleRequestModel(SendBuffer);
            SimpleRequestReceiverValue = global::com.simulation.contract.SimpleRequest.Default;
            SimpleRequestReceiverModel = new SimpleRequestModel();
            SimpleResponseSenderModel = new SimpleResponseModel(SendBuffer);
            SimpleResponseReceiverValue = global::com.simulation.contract.SimpleResponse.Default;
            SimpleResponseReceiverModel = new SimpleResponseModel();
            LoginMessageSenderModel = new LoginMessageModel(SendBuffer);
            LoginMessageReceiverValue = global::com.simulation.contract.LoginMessage.Default;
            LoginMessageReceiverModel = new LoginMessageModel();
            _requestsByIdSimpleResponse = new Dictionary<Guid, Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.simulation.contract.SimpleResponse>>>();
            _requestsByTimestampSimpleResponse = new SortedDictionary<DateTime, Guid>();
        }

        public Task<global::com.simulation.contract.SimpleResponse> Request(global::com.simulation.contract.SimpleRequest value) { return RequestListener(this, value, TimeSpan.Zero); }
        public Task<global::com.simulation.contract.SimpleResponse> Request(global::com.simulation.contract.SimpleRequest value, TimeSpan timeout) { return RequestListener(this, value, timeout); }
        public Task<global::com.simulation.contract.SimpleResponse> RequestListener(IClientListener listener, global::com.simulation.contract.SimpleRequest value) { return RequestListener(listener, value, TimeSpan.Zero); }
        public Task<global::com.simulation.contract.SimpleResponse> RequestListener(IClientListener listener, global::com.simulation.contract.SimpleRequest value, TimeSpan timeout)
        {
            lock (Lock)
            {
                TaskCompletionSource<global::com.simulation.contract.SimpleResponse> source = new TaskCompletionSource<global::com.simulation.contract.SimpleResponse>();
                Task<global::com.simulation.contract.SimpleResponse> task = source.Task;

                DateTime current = DateTime.UtcNow;

                // Send the request message
                long serialized = SendListener(listener, value);
                if (serialized > 0)
                {
                    // Calculate the unique timestamp
                    Timestamp = (current <= Timestamp) ? new DateTime(Timestamp.Ticks + 1) : current;

                    // Register the request
                    _requestsByIdSimpleResponse.Add(value.id, new Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.simulation.contract.SimpleResponse>>(Timestamp, timeout, source));
                    if (timeout.Ticks > 0)
                        _requestsByTimestampSimpleResponse.Add(Timestamp, value.id);
                }
                else
                    source.SetException(new Exception("Send request failed!"));

                return task;
            }
        }

        public long Send(object obj) { return SendListener(this, obj); }
        public long SendListener(IClientListener listener, object obj)
        {
            switch (obj)
            {
                case global::com.simulation.contract.SimpleMessage value when value.FBEType == global::com.simulation.contract.SimpleMessage.FBETypeConst: return SendListener(listener, value);
                case global::com.simulation.contract.SimpleRequest value when value.FBEType == global::com.simulation.contract.SimpleRequest.FBETypeConst: return SendListener(listener, value);
                case global::com.simulation.contract.SimpleResponse value when value.FBEType == global::com.simulation.contract.SimpleResponse.FBETypeConst: return SendListener(listener, value);
                case global::com.simulation.contract.LoginMessage value when value.FBEType == global::com.simulation.contract.LoginMessage.FBETypeConst: return SendListener(listener, value);
                default: break;
            }

            return 0;
        }

        public long Send(global::com.simulation.contract.SimpleMessage value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::com.simulation.contract.SimpleMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.SimpleMessage serialization failed!");
            Debug.Assert(SimpleMessageSenderModel.Verify(), "com.simulation.contract.SimpleMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.simulation.contract.SimpleRequest value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::com.simulation.contract.SimpleRequest value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleRequestSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.SimpleRequest serialization failed!");
            Debug.Assert(SimpleRequestSenderModel.Verify(), "com.simulation.contract.SimpleRequest validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.simulation.contract.SimpleResponse value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::com.simulation.contract.SimpleResponse value)
        {
            // Serialize the value into the FBE stream
            long serialized = SimpleResponseSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.SimpleResponse serialization failed!");
            Debug.Assert(SimpleResponseSenderModel.Verify(), "com.simulation.contract.SimpleResponse validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }
        public long Send(global::com.simulation.contract.LoginMessage value) { return SendListener(this, value); }
        public long SendListener(IClientListener listener, global::com.simulation.contract.LoginMessage value)
        {
            // Serialize the value into the FBE stream
            long serialized = LoginMessageSenderModel.Serialize(value);
            Debug.Assert((serialized > 0), "com.simulation.contract.LoginMessage serialization failed!");
            Debug.Assert(LoginMessageSenderModel.Verify(), "com.simulation.contract.LoginMessage validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                listener.OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(listener, serialized);
        }

        public bool OnReceiveResponse(global::com.simulation.contract.SimpleResponse response)
        {
            ReceivedResponse_SimpleResponse?.Invoke(response);

            lock (Lock)
            {
                if (_requestsByIdSimpleResponse.TryGetValue(response.id, out Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.simulation.contract.SimpleResponse>> tuple))
                {
                    var timestamp = tuple.Item1;
                    var timespan = tuple.Item2;
                    var source = tuple.Item3;
                    source.SetResult(response);
                    _requestsByIdSimpleResponse.Remove(response.id);
                    _requestsByTimestampSimpleResponse.Remove(timestamp);
                    return true;
                }

                return false;
            }
        }

        public bool OnReceiveResponse(global::com.simulation.contract.SimpleMessage response) { ReceivedResponse_SimpleMessage?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::com.simulation.contract.SimpleRequest response) { ReceivedResponse_SimpleRequest?.Invoke(response); return false; }
        public bool OnReceiveResponse(global::com.simulation.contract.LoginMessage response) { ReceivedResponse_LoginMessage?.Invoke(response); return false; }

        public bool OnReceiveReject(global::com.simulation.contract.SimpleMessage reject) { ReceivedReject_SimpleMessage?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::com.simulation.contract.SimpleRequest reject) { ReceivedReject_SimpleRequest?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::com.simulation.contract.SimpleResponse reject) { ReceivedReject_SimpleResponse?.Invoke(reject); return false; }
        public bool OnReceiveReject(global::com.simulation.contract.LoginMessage reject) { ReceivedReject_LoginMessage?.Invoke(reject); return false; }

        public void OnReceiveNotify(global::com.simulation.contract.SimpleMessage notify) { ReceivedNotify_SimpleMessage?.Invoke(notify); }
        public void OnReceiveNotify(global::com.simulation.contract.SimpleRequest notify) { ReceivedNotify_SimpleRequest?.Invoke(notify); }
        public void OnReceiveNotify(global::com.simulation.contract.SimpleResponse notify) { ReceivedNotify_SimpleResponse?.Invoke(notify); }
        public void OnReceiveNotify(global::com.simulation.contract.LoginMessage notify) { ReceivedNotify_LoginMessage?.Invoke(notify); }

        public void OnReceive(global::com.simulation.contract.SimpleMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::com.simulation.contract.SimpleRequest value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::com.simulation.contract.SimpleResponse value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }
        public void OnReceive(global::com.simulation.contract.LoginMessage value) { if (!OnReceiveResponse(value) && !OnReceiveReject(value)) OnReceiveNotify(value); }

        // Reset client requests
        internal override void ResetRequests()
        {
            base.ResetRequests();

            foreach(var request in _requestsByIdSimpleResponse)
                request.Value.Item3.SetException(new Exception("Reset client!"));
            _requestsByIdSimpleResponse.Clear();
            _requestsByTimestampSimpleResponse.Clear();
        }

        // Watchdog client requests for timeouts
        internal override void WatchdogRequests(DateTime utc)
        {
            base.WatchdogRequests(utc);

            while (_requestsByTimestampSimpleResponse.Count > 0)
            {
                var request = _requestsByTimestampSimpleResponse.First();
                Tuple<DateTime, TimeSpan, TaskCompletionSource<global::com.simulation.contract.SimpleResponse>> tuple;
                _requestsByIdSimpleResponse.TryGetValue(request.Value, out tuple);
                var timestamp = tuple.Item1;
                var timespan = tuple.Item2;
                if ((timestamp + timespan) <= utc)
                {
                    var source = tuple.Item3;
                    source.SetException(new Exception("Timeout!"));
                    _requestsByIdSimpleResponse.Remove(request.Value);
                    _requestsByTimestampSimpleResponse.Remove(timestamp);
                    continue;
                }
                else
                    break;
            }
        }

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size) { return OnReceiveListener(this, type, buffer, offset, size); }
        internal bool OnReceiveListener(IClientListener listener, long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case SimpleMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(SimpleMessageReceiverModel.Verify(), "com.simulation.contract.SimpleMessage validation failed!");
                    long deserialized = SimpleMessageReceiverModel.Deserialize(out SimpleMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.SimpleMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleMessageReceiverValue);
                    return true;
                }
                case SimpleRequestModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleRequestReceiverModel.Attach(buffer, offset);
                    Debug.Assert(SimpleRequestReceiverModel.Verify(), "com.simulation.contract.SimpleRequest validation failed!");
                    long deserialized = SimpleRequestReceiverModel.Deserialize(out SimpleRequestReceiverValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.SimpleRequest deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleRequestReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleRequestReceiverValue);
                    return true;
                }
                case SimpleResponseModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    SimpleResponseReceiverModel.Attach(buffer, offset);
                    Debug.Assert(SimpleResponseReceiverModel.Verify(), "com.simulation.contract.SimpleResponse validation failed!");
                    long deserialized = SimpleResponseReceiverModel.Deserialize(out SimpleResponseReceiverValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.SimpleResponse deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = SimpleResponseReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(SimpleResponseReceiverValue);
                    return true;
                }
                case LoginMessageModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    LoginMessageReceiverModel.Attach(buffer, offset);
                    Debug.Assert(LoginMessageReceiverModel.Verify(), "com.simulation.contract.LoginMessage validation failed!");
                    long deserialized = LoginMessageReceiverModel.Deserialize(out LoginMessageReceiverValue);
                    Debug.Assert((deserialized > 0), "com.simulation.contract.LoginMessage deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = LoginMessageReceiverValue.ToString();
                        listener.OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    listener.OnReceive(LoginMessageReceiverValue);
                    return true;
                }
                default: break;
            }

            return false;
        }

        public delegate void ReceiveResponseHandler_SimpleResponse(global::com.simulation.contract.SimpleResponse response);
        public event ReceiveResponseHandler_SimpleResponse ReceivedResponse_SimpleResponse = (response) => {};
        public delegate void ReceiveResponseHandler_SimpleMessage(global::com.simulation.contract.SimpleMessage response);
        public event ReceiveResponseHandler_SimpleMessage ReceivedResponse_SimpleMessage = (response) => {};
        public delegate void ReceiveResponseHandler_SimpleRequest(global::com.simulation.contract.SimpleRequest response);
        public event ReceiveResponseHandler_SimpleRequest ReceivedResponse_SimpleRequest = (response) => {};
        public delegate void ReceiveResponseHandler_LoginMessage(global::com.simulation.contract.LoginMessage response);
        public event ReceiveResponseHandler_LoginMessage ReceivedResponse_LoginMessage = (response) => {};
        public delegate void ReceiveRejectHandler_SimpleMessage(global::com.simulation.contract.SimpleMessage reject);
        public event ReceiveRejectHandler_SimpleMessage ReceivedReject_SimpleMessage = (reject) => {};
        public delegate void ReceiveRejectHandler_SimpleRequest(global::com.simulation.contract.SimpleRequest reject);
        public event ReceiveRejectHandler_SimpleRequest ReceivedReject_SimpleRequest = (reject) => {};
        public delegate void ReceiveRejectHandler_SimpleResponse(global::com.simulation.contract.SimpleResponse reject);
        public event ReceiveRejectHandler_SimpleResponse ReceivedReject_SimpleResponse = (reject) => {};
        public delegate void ReceiveRejectHandler_LoginMessage(global::com.simulation.contract.LoginMessage reject);
        public event ReceiveRejectHandler_LoginMessage ReceivedReject_LoginMessage = (reject) => {};
        public delegate void ReceiveNotifyHandler_SimpleMessage(global::com.simulation.contract.SimpleMessage notify);
        public event ReceiveNotifyHandler_SimpleMessage ReceivedNotify_SimpleMessage = (notify) => {};
        public delegate void ReceiveNotifyHandler_SimpleRequest(global::com.simulation.contract.SimpleRequest notify);
        public event ReceiveNotifyHandler_SimpleRequest ReceivedNotify_SimpleRequest = (notify) => {};
        public delegate void ReceiveNotifyHandler_SimpleResponse(global::com.simulation.contract.SimpleResponse notify);
        public event ReceiveNotifyHandler_SimpleResponse ReceivedNotify_SimpleResponse = (notify) => {};
        public delegate void ReceiveNotifyHandler_LoginMessage(global::com.simulation.contract.LoginMessage notify);
        public event ReceiveNotifyHandler_LoginMessage ReceivedNotify_LoginMessage = (notify) => {};
    }

} // namespace com.simulation.contract.FBE
